/**
 * Custom Order Utilities
 * Centralized utility functions for custom order operations
 * @namespace CustomOrderUtils
 */

class CustomOrderUtils {
  /**
   * Gets the configured custom order product title from theme settings
   * Uses dependency injection pattern - depends on window.customOrderSettings abstraction
   * @returns {string} - Custom order product title (default: "Custom Order")
   */
  static getCustomOrderProductTitle() {
    // Primary: Get from global settings object (set in custom-scripts-loader.liquid)
    // This ensures settings persist even if theme.liquid is overwritten
    if (window.customOrderSettings && window.customOrderSettings.productTitle) {
      const title = String(window.customOrderSettings.productTitle).trim();
      if (title !== '') {
        return title;
      }
    }

    // Fallback: Get from custom measurements config if available
    if (window.customMeasurementsConfig && window.customMeasurementsConfig.customOrderProductTitle) {
      const title = String(window.customMeasurementsConfig.customOrderProductTitle).trim();
      if (title !== '') {
        return title;
      }
    }

    // Final fallback to default
    return 'Custom Order';
  }

  /**
   * Determines if a cart item is a custom order
   * Checks product title against configured custom order product title
   * Also checks properties for backward compatibility during migration
   * @param {Object} item - Cart item object
   * @returns {boolean} - True if item is a custom order
   */
  static isCustomOrderItem(item) {
    if (!item) return false;

    const customOrderTitle = this.getCustomOrderProductTitle();

    // Primary method: Check product title
    // Cart API may have product.title or product_title
    let productTitle = null;
    if (item.product && item.product.title) {
      productTitle = String(item.product.title).trim();
    } else if (item.product_title) {
      productTitle = String(item.product_title).trim();
    }

    if (productTitle && productTitle.toLowerCase() === customOrderTitle.toLowerCase()) {
      return true;
    }

    // Backward compatibility: Check properties (for migration period)
    if (item.properties) {
      const customFlag = item.properties['_custom'] || item.properties['Order Type'];
      if (typeof customFlag === 'string' && customFlag.toLowerCase() === 'custom') {
        return true;
      }
    }

    return false;
  }

  /**
   * Determines if a property should be filtered out
   * Filters empty, zero, and internal (underscore-prefixed) properties
   * Also filters properties with "- Text" suffix that are empty
   * @param {string} propertyName - Property name
   * @param {string} propertyValue - Property value
   * @returns {boolean} - True if property should be filtered
   */
  static shouldFilterProperty(propertyName, propertyValue) {
    if (!propertyName) return false;

    // Filter internal properties (starting with underscore)
    if (propertyName.charAt(0) === '_') {
      return true;
    }

    // Convert value to string and trim
    const stringValue = propertyValue != null ? String(propertyValue) : '';
    const trimmedValue = stringValue.trim();

    // Filter empty/blank values (including null, undefined, empty string, whitespace-only)
    if (trimmedValue === '') {
      return true;
    }

    // Filter properties with "- Text" or " - Text" suffix that are empty
    // These are generated by Shopify for "Other" option text inputs
    if ((propertyName.endsWith('- Text') || propertyName.endsWith(' - Text')) && trimmedValue === '') {
      return true;
    }

    // Filter zero values (0, 0.0, 0.00, 0.000, etc.)
    const numValue = parseFloat(trimmedValue);

    if (!isNaN(numValue) && numValue === 0) {
      // Check if the string representation is just zeros (with optional decimal point)
      const zeroPattern = /^0+(\.0+)?$/;
      if (zeroPattern.test(trimmedValue)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Filters cart item properties, removing empty, zero, and internal properties
   * @param {Object} properties - Cart item properties object
   * @returns {Object} - Filtered properties object
   */
  static filterCartItemProperties(properties) {
    if (!properties || typeof properties !== 'object') {
      return {};
    }

    const filtered = {};

    for (const [key, value] of Object.entries(properties)) {
      if (!this.shouldFilterProperty(key, value)) {
        filtered[key] = value;
      }
    }

    return filtered;
  }

  /**
   * Builds product page URL with query parameters for editing
   * @param {string} productHandle - Product handle
   * @param {Object} properties - Cart item properties
   * @returns {string} - Product page URL with query parameters
   */
  static buildEditUrl(productHandle, properties) {
    if (!productHandle) return '/';

    const baseUrl = `/products/${productHandle}`;
    const filteredProperties = this.filterCartItemProperties(properties);

    const params = new URLSearchParams();

    for (const [key, value] of Object.entries(filteredProperties)) {
      // Skip internal properties
      if (key.charAt(0) === '_') continue;

      // Encode property name and value
      const encodedKey = encodeURIComponent(key);
      const encodedValue = encodeURIComponent(String(value));
      params.append(encodedKey, encodedValue);
    }

    const queryString = params.toString();
    return queryString ? `${baseUrl}?${queryString}` : baseUrl;
  }

  /**
   * Parses URL query parameters for form pre-filling
   * @returns {Object} - Parsed property values
   */
  static parseUrlParams() {
    const params = new URLSearchParams(window.location.search);
    const properties = {};

    for (const [key, value] of params.entries()) {
      // Decode property name and value
      const decodedKey = decodeURIComponent(key);
      const decodedValue = decodeURIComponent(value);
      properties[decodedKey] = decodedValue;
    }

    return properties;
  }

  /**
   * Waits for customMeasurementsConfig to be available
   * @param {number} timeout - Maximum time to wait in milliseconds (default: 2000)
   * @returns {Promise<Object|null>} - Config object or null if timeout
   */
  static async waitForConfig(timeout = 2000) {
    // If config is already available, return it immediately
    if (window.customMeasurementsConfig) {
      return window.customMeasurementsConfig;
    }

    // Wait for config to be loaded
    return new Promise((resolve) => {
      const startTime = Date.now();
      const checkInterval = 50; // Check every 50ms

      const checkConfig = () => {
        if (window.customMeasurementsConfig) {
          resolve(window.customMeasurementsConfig);
          return;
        }

        const elapsed = Date.now() - startTime;
        if (elapsed >= timeout) {
          // Timeout reached, resolve with null
          resolve(null);
          return;
        }

        // Check again after interval
        setTimeout(checkConfig, checkInterval);
      };

      checkConfig();
    });
  }

  /**
   * Checks if URL parameters contain edit-related parameters
   * Used to distinguish edit mode from marketing/tracking parameters
   * Derives parameter detection from theme settings config
   * Waits for config to be available if needed
   * @returns {Promise<boolean>} - True if URL contains edit-related parameters
   */
  static async hasEditRelatedParams() {
    const urlParams = this.parseUrlParams();
    if (!urlParams || Object.keys(urlParams).length === 0) {
      return false;
    }

    // Wait for config to be available (with timeout)
    const config = await this.waitForConfig(2000);
    if (!config) {
      // Fallback: if config not available after timeout, use pattern matching only
      return this.hasEditRelatedParamsByPattern(urlParams);
    }

    // Build set of all valid option values from config
    const validOptionValues = new Set();

    // Add categories (for "Selected Option" param)
    if (config.categories && Array.isArray(config.categories)) {
      config.categories.forEach((cat) => validOptionValues.add(String(cat).trim()));
    }

    // Add all option values from config.options
    if (config.options) {
      const optionArrays = [
        config.options.associates,
        config.options.leatherColors,
        config.options.harnessTypes,
        config.options.tagOptions,
        config.options.frontPlates,
        config.options.backPlates,
        config.options.longSliders,
      ];

      optionArrays.forEach((arr) => {
        if (Array.isArray(arr)) {
          arr.forEach((val) => validOptionValues.add(String(val).trim()));
        }
      });
    }

    // Build set of measurement names from config
    const measurementNames = new Set();
    if (config.measurements) {
      Object.keys(config.measurements).forEach((name) => measurementNames.add(String(name).trim()));
    }

    // Check if any URL param value or name matches config data
    for (const [paramName, paramValue] of Object.entries(urlParams)) {
      const value = String(paramValue).trim();
      const name = String(paramName).trim();

      // Check if param value exactly matches any config option value
      if (validOptionValues.has(value)) {
        return true;
      }

      // Check if param name exactly matches a measurement name from config
      if (measurementNames.has(name)) {
        return true;
      }

      // Check if param name contains any measurement name from config as a substring
      // This handles cases where measurement name appears in the param name
      // (e.g., "Neck (in)" contains "Neck" from config)
      for (const measName of measurementNames) {
        if (name.includes(measName)) {
          return true;
        }
      }

      // Check if any word in param name matches a measurement name
      // Split param name by common delimiters and check each part
      const nameParts = name.split(/[\s\(\)\[\]_-]+/);
      for (const part of nameParts) {
        const trimmedPart = part.trim();
        if (trimmedPart && measurementNames.has(trimmedPart)) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * Fallback method: checks for edit-related parameters by pattern matching
   * Used when config is not available
   * Without config, we cannot reliably detect edit params
   * Return false to avoid false positives from marketing params
   * @param {Object} urlParams - Parsed URL parameters
   * @returns {boolean} - Always returns false (requires config for accurate detection)
   */
  static hasEditRelatedParamsByPattern(urlParams) {
    // Without config, we cannot determine which params are edit-related
    // Return false to avoid false positives from marketing/tracking parameters
    return false;
  }

  /**
   * Determines if a FormData object represents a custom order
   * Used for form submission detection - checks if product title matches
   * @param {FormData} formData - Form data object
   * @param {string} productTitle - Product title from the form's product
   * @returns {boolean} - True if form data represents a custom order
   */
  static isCustomOrderFromFormData(formData, productTitle) {
    if (!formData) return false;

    // Primary method: Check product title
    if (productTitle) {
      const customOrderTitle = this.getCustomOrderProductTitle();
      if (String(productTitle).trim().toLowerCase() === customOrderTitle.toLowerCase()) {
        return true;
      }
    }

    // Backward compatibility: Check properties (for migration period)
    const orderType = formData.get('properties[Order Type]');
    const customFlag = formData.get('properties[_custom]');

    return (
      (typeof orderType === 'string' && orderType.toLowerCase() === 'custom') ||
      (typeof customFlag === 'string' && customFlag.toLowerCase() === 'custom')
    );
  }
}

// Export to window namespace (following theme pattern)
window.CustomOrderUtils = CustomOrderUtils;
